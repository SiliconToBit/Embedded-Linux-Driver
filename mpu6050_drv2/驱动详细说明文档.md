# MPU6050 Linux 驱动详细说明文档

## 目录
1. [驱动概述](#1-驱动概述)
2. [硬件连接](#2-硬件连接)
3. [驱动架构](#3-驱动架构)
4. [中断机制详解](#4-中断机制详解)
5. [驱动工作流程](#5-驱动工作流程)
6. [应用程序说明](#6-应用程序说明)
7. [编译和部署](#7-编译和部署)
8. [使用示例](#8-使用示例)
9. [故障排查](#9-故障排查)

---

## 1. 驱动概述

### 1.1 功能简介
本驱动为MPU6050六轴传感器（3轴加速度计 + 3轴陀螺仪）提供Linux内核驱动支持。驱动采用中断驱动模式，当传感器数据就绪时触发中断，通知应用程序读取数据，避免了轮询方式带来的CPU资源浪费。

### 1.2 主要特性
- **I2C通信协议**：通过I2C总线与MPU6050通信
- **中断驱动**：使用硬件中断机制，数据就绪时自动通知
- **阻塞式读取**：应用程序可阻塞等待新数据，无需轮询
- **Threaded IRQ**：使用线程化中断处理，允许在中断上下文中执行I2C操作
- **字符设备接口**：提供标准的字符设备接口供用户空间访问

### 1.3 文件结构
```
mpu6050_drv2/
├── driver/
│   ├── mpu6050_drv.c    # 内核驱动源码
│   └── Makefile         # 驱动编译配置
├── app/
│   └── mpu6050_app.c    # 用户空间应用程序
├── README.md            # 设备树配置说明
└── Makefile             # 主编译配置
```

---

## 2. 硬件连接

### 2.1 MPU6050引脚说明

| 引脚 | 功能 | 连接说明 |
|------|------|----------|
| VCC  | 电源 | 3.3V供电 |
| GND  | 地 | 接地 |
| SCL  | I2C时钟 | 连接I2C总线的SCL |
| SDA  | I2C数据 | 连接I2C总线的SDA |
| AD0  | 地址选择 | 接地→0x68，接VCC→0x69 |
| INT  | 中断输出 | 连接GPIO中断引脚 |

### 2.2 典型连接示例
```
MPU6050              开发板
-------             ---------
VCC    -------->    3.3V
GND    -------->    GND
SCL    -------->    I2C1_SCL
SDA    -------->    I2C1_SDA
AD0    -------->    GND (地址0x68)
INT    -------->    GPIO1_B3 (示例)
```

---

## 3. 驱动架构

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     用户空间应用程序                         │
│  (mpu6050_app.c - 卡尔曼滤波、角度计算)                     │
└────────────────────┬────────────────────────────────────────┘
                     │ read() 阻塞读取
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                    字符设备接口                             │
│  /dev/mpu6050 - file_operations (open, read)               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                    驱动核心层                               │
│  - 等待队列管理 (wait_queue_head_t)                        │
│  - 中断标志位 (data_ready)                                 │
│  - 设备管理 (cdev, class, device)                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                  中断处理层                                 │
│  - Threaded IRQ (mpu6050_irq_thread)                       │
│  - 中断服务程序 (运行在内核线程)                            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                   I2C通信层                                 │
│  - i2c_smbus_read_i2c_block_data()                          │
│  - i2c_smbus_write_byte_data()                             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                  硬件层 (MPU6050)                           │
│  - 加速度计 + 陀螺仪                                        │
│  - 中断生成 (DATA_RDY_EN)                                  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心数据结构

```c
struct mpu6050_dev
{
    dev_t dev_id;              // 设备号
    struct cdev cdev;          // 字符设备结构
    struct class *class;       // 设备类
    struct device *device;     // 设备
    struct i2c_client *client; // I2C客户端

    // --- 中断相关 ---
    int irq;                   // 中断号
    wait_queue_head_t read_wq; // 等待队列
    int data_ready;            // 数据就绪标志 (1:有数据, 0:无数据)
};
```

### 3.3 寄存器定义

| 寄存器地址 | 名称 | 功能 |
|-----------|------|------|
| 0x19 | SMPLRT_DIV | 采样率分频器 |
| 0x1A | CONFIG | 数字低通滤波器配置 |
| 0x37 | INT_PIN_CFG | 中断引脚配置 |
| 0x38 | INT_ENABLE | 中断使能 |
| 0x3A | INT_STATUS | 中断状态 |
| 0x3B | ACCEL_XOUT_H | 加速度X轴高字节 |
| 0x6B | PWR_MGMT_1 | 电源管理 |
| 0x75 | WHO_AM_I | 设备ID |

---

## 4. 中断机制详解

### 4.1 为什么使用中断？

**轮询方式的问题**：
- CPU需要不断查询数据状态
- 大量时间浪费在无意义的检查上
- 响应延迟不可预测

**中断方式的优势**：
- 数据就绪时自动通知CPU
- CPU可执行其他任务或休眠
- 响应时间确定，实时性好
- 降低功耗

### 4.2 中断配置详解

#### 4.2.1 INT_PIN_CFG (0x37) 配置
```c
i2c_smbus_write_byte_data(client, REG_INT_PIN_CFG, 0xA0);
```

| 位 | 名称 | 值 | 说明 |
|----|------|-----|------|
| Bit 7 | INT_LEVEL | 1 | Active Low (低电平有效) |
| Bit 5 | LATCH_INT_EN | 1 | 锁存中断，直到读取状态寄存器 |
| Bit 4 | INT_RD_CLEAR | 0 | 读取任何寄存器不清除中断 |

**0xA0 = 10100000b**：
- 低电平触发：中断引脚平时为高，中断时拉低
- 锁存模式：中断信号保持，直到软件清除

#### 4.2.2 INT_ENABLE (0x38) 配置
```c
i2c_smbus_write_byte_data(client, REG_INT_ENABLE, 0x01);
```

| 位 | 名称 | 值 | 说明 |
|----|------|-----|------|
| Bit 0 | DATA_RDY_EN | 1 | 数据就绪中断使能 |

### 4.3 Threaded IRQ机制

#### 4.3.1 为什么使用Threaded IRQ？

**普通IRQ的限制**：
- 运行在中断上下文，不能睡眠
- 不能执行可能阻塞的操作（如I2C通信）
- 执行时间必须很短

**Threaded IRQ的优势**：
- 中断处理分为两部分：
  - **Primary Handler**：快速响应，最小化延迟
  - **Threaded Handler**：运行在内核线程，可以睡眠和执行I2C操作

#### 4.3.2 中断注册代码
```c
devm_request_threaded_irq(&client->dev, mpu->irq,
                          NULL,                // Primary handler (使用默认)
                          mpu6050_irq_thread,  // Thread handler
                          IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_SHARED,
                          DRIVER_NAME,
                          mpu);
```

**参数说明**：
- `IRQF_TRIGGER_FALLING`：下降沿触发（配合Active Low）
- `IRQF_ONESHOT`：Threaded IRQ必须设置
- `IRQF_SHARED`：共享中断线

#### 4.3.3 中断处理函数
```c
static irqreturn_t mpu6050_irq_thread(int irq, void *dev_id)
{
    struct mpu6050_dev *mpu = dev_id;

    // 1. 读取状态寄存器，清除中断标志
    i2c_smbus_read_byte_data(mpu->client, REG_INT_STATUS);

    // 2. 设置数据就绪标志
    mpu->data_ready = 1;

    // 3. 唤醒等待队列中的进程
    wake_up_interruptible(&mpu->read_wq);

    return IRQ_HANDLED;
}
```

**执行流程**：
1. MPU6050产生中断，GPIO引脚拉低
2. 内核调用Primary Handler（默认实现）
3. 唤醒Threaded Handler线程
4. Threaded Handler读取状态寄存器清除中断
5. 设置data_ready标志
6. 唤醒在read()中等待的进程

### 4.4 等待队列机制

#### 4.4.1 等待队列初始化
```c
init_waitqueue_head(&mpu->read_wq);
```

#### 4.4.2 阻塞等待数据
```c
ret = wait_event_interruptible(mpu->read_wq, mpu->data_ready != 0);
```

**工作原理**：
- 检查条件 `mpu->data_ready != 0`
- 如果条件为假（无数据），进程进入睡眠状态
- 进程被移出CPU调度队列
- 当`wake_up_interruptible()`被调用时，进程被唤醒
- 唤醒后重新检查条件，如果满足则继续执行

#### 4.4.3 唤醒等待进程
```c
wake_up_interruptible(&mpu->read_wq);
```

---

## 5. 驱动工作流程

### 5.1 初始化流程

```
系统启动
    ↓
I2C总线初始化
    ↓
设备树解析 (mpu6050@68)
    ↓
调用 probe() 函数
    ↓
┌─────────────────────────────────┐
│ 1. 分配设备结构体内存            │
│    devm_kzalloc()               │
├─────────────────────────────────┤
│ 2. 初始化等待队列                │
│    init_waitqueue_head()        │
├─────────────────────────────────┤
│ 3. 硬件初始化                    │
│    - 复位/唤醒 MPU6050          │
│    - 配置采样率                  │
│    - 配置低通滤波器              │
│    - 配置中断引脚                │
│    - 禁用中断（防止中断风暴）    │
├─────────────────────────────────┤
│ 4. 注册字符设备                  │
│    - alloc_chrdev_region()      │
│    - cdev_init()                │
│    - cdev_add()                 │
│    - class_create()             │
│    - device_create()            │
├─────────────────────────────────┤
│ 5. 申请中断                      │
│    devm_request_threaded_irq()  │
├─────────────────────────────────┤
│ 6. 使能MPU6050内部中断           │
│    INT_ENABLE = 0x01            │
└─────────────────────────────────┘
    ↓
驱动就绪，等待数据
```

### 5.2 数据读取流程

```
应用程序调用 read()
    ↓
┌─────────────────────────────────┐
│ mpu6050_read() 被调用           │
├─────────────────────────────────┤
│ 检查 data_ready 标志            │
│    ↓                            │
│  data_ready == 0?               │
│    ↓ Yes                        │
│  进程进入睡眠                    │
│  wait_event_interruptible()     │
│    ↓                            │
│  [进程被挂起，CPU可执行其他任务] │
└─────────────────────────────────┘
    ↓
[MPU6050产生新数据]
    ↓
[GPIO中断触发]
    ↓
┌─────────────────────────────────┐
│ mpu6050_irq_thread() 执行        │
├─────────────────────────────────┤
│ 1. 读取 INT_STATUS 清除中断     │
├─────────────────────────────────┤
│ 2. 设置 data_ready = 1          │
├─────────────────────────────────┤
│ 3. 唤醒等待队列                  │
│    wake_up_interruptible()      │
└─────────────────────────────────┘
    ↓
[read() 进程被唤醒]
    ↓
┌─────────────────────────────────┐
│ mpu6050_read() 继续执行          │
├─────────────────────────────────┤
│ 1. 清除 data_ready = 0          │
├─────────────────────────────────┤
│ 2. 读取14字节数据                │
│    i2c_smbus_read_i2c_block...  │
│    - 加速度 X/Y/Z (6字节)        │
│    - 温度 (2字节)                │
│    - 陀螺仪 X/Y/Z (6字节)        │
├─────────────────────────────────┤
│ 3. 拷贝数据到用户空间            │
│    copy_to_user()               │
├─────────────────────────────────┤
│ 4. 返回读取字节数 (14)           │
└─────────────────────────────────┘
    ↓
应用程序获得数据
```

### 5.3 数据格式

```c
struct mpu_raw_data {
    uint8_t accel_x_h;  // 加速度X轴高字节
    uint8_t accel_x_l;  // 加速度X轴低字节
    uint8_t accel_y_h;  // 加速度Y轴高字节
    uint8_t accel_y_l;  // 加速度Y轴低字节
    uint8_t accel_z_h;  // 加速度Z轴高字节
    uint8_t accel_z_l;  // 加速度Z轴低字节
    uint8_t temp_h;     // 温度高字节
    uint8_t temp_l;     // 温度低字节
    uint8_t gyro_x_h;   // 陀螺仪X轴高字节
    uint8_t gyro_x_l;   // 陀螺仪X轴低字节
    uint8_t gyro_y_h;   // 陀螺仪Y轴高字节
    uint8_t gyro_y_l;   // 陀螺仪Y轴低字节
    uint8_t gyro_z_h;   // 陀螺仪Z轴高字节
    uint8_t gyro_z_l;   // 陀螺仪Z轴低字节
};  // 共14字节
```

---

## 6. 应用程序说明

### 6.1 应用程序功能

应用程序实现了以下功能：
1. **零点校准**：启动时自动校准陀螺仪零点偏移
2. **数据转换**：将原始数据转换为物理单位
3. **卡尔曼滤波**：融合加速度计和陀螺仪数据
4. **角度计算**：计算Roll、Pitch、Yaw姿态角
5. **死区处理**：消除静止时的微小漂移

### 6.2 卡尔曼滤波器原理

#### 6.2.1 为什么需要卡尔曼滤波？

**加速度计的问题**：
- 长期稳定，无漂移
- 短期噪声大，受震动影响
- 无法测量旋转速度

**陀螺仪的问题**：
- 短期精度高，响应快
- 长期有积分漂移
- 零点偏移会累积

**卡尔曼滤波的优势**：
- 结合两者优点
- 短期相信陀螺仪
- 长期相信加速度计
- 自动调整权重

#### 6.2.2 卡尔曼滤波器结构

```c
typedef struct {
    float Q_angle;   // 过程噪声协方差 (角度)
    float Q_bias;    // 过程噪声协方差 (偏差)
    float R_measure; // 测量噪声协方差

    float angle;     // 输出角度
    float bias;      // 输出陀螺仪偏差
    float P[2][2];   // 误差协方差矩阵
} Kalman_t;
```

#### 6.2.3 滤波算法流程

```
┌─────────────────────────────────────────────────┐
│ 1. 预测阶段 (Predict)                            │
├─────────────────────────────────────────────────┤
│    rate = newRate - bias                         │
│    angle += dt * rate                            │
│    更新协方差矩阵 P                               │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 2. 更新阶段 (Update)                             │
├─────────────────────────────────────────────────┤
│    计算卡尔曼增益 K                                │
│    y = newAngle - angle  (创新/残差)             │
│    angle += K[0] * y                             │
│    bias += K[1] * y                              │
│    更新协方差矩阵 P                               │
└─────────────────────────────────────────────────┘
                    ↓
              返回融合后的角度
```

### 6.3 角度计算公式

#### 6.3.1 Roll (横滚角)
绕X轴旋转的角度
```c
float acc_roll = atan2(ay, az) * RAD_TO_DEG;
```

#### 6.3.2 Pitch (俯仰角)
绕Y轴旋转的角度
```c
float acc_pitch = atan2(-ax, sqrt(ay*ay + az*az)) * RAD_TO_DEG;
```

#### 6.3.3 Yaw (偏航角)
绕Z轴旋转的角度（仅陀螺仪积分）
```c
yaw += gz * dt;
```

### 6.4 数据转换系数

| 传感器 | 原始值范围 | 转换系数 | 物理单位 |
|--------|-----------|---------|---------|
| 加速度计 | ±32768 | 1/16384 | g (9.8m/s²) |
| 陀螺仪 | ±32768 | 1/131 | °/s |
| 温度 | - | 1/340 + 36.53 | °C |

### 6.5 零点校准流程

```c
// 采集500次数据求平均
for (int i = 0; i < 500; i++) {
    读取陀螺仪数据;
    累加;
    延时2ms;
}
// 计算平均值作为零点偏移
gyro_bias_x = gx_sum / 500 / 131.0;
gyro_bias_y = gy_sum / 500 / 131.0;
gyro_bias_z = gz_sum / 500 / 131.0;
```

### 6.6 死区处理

```c
// 消除微小漂移
if (fabs(gx) < 0.05) gx = 0;
if (fabs(gy) < 0.05) gy = 0;
if (fabs(gz) < 0.05) gz = 0;
```

---

## 7. 编译和部署

### 7.1 编译驱动

#### 7.1.1 准备编译环境
```bash
# 安装必要的工具
sudo apt-get install build-essential linux-headers-$(uname -r)
```

#### 7.1.2 编译内核模块
```bash
cd /home/gm/Workspace/LinuxDriver/mpu6050_drv2
make
```

编译成功后会生成 `driver/mpu6050_drv.ko` 内核模块文件。

### 7.2 编译应用程序

```bash
cd /home/gm/Workspace/LinuxDriver/mpu6050_drv2/app
gcc -o mpu6050_app mpu6050_app.c -lm
```

### 7.3 部署步骤

#### 7.3.1 配置设备树

参考 [README.md](file:///home/gm/Workspace/LinuxDriver/mpu6050_drv2/README.md) 中的设备树配置说明。

关键配置项：
```dts
&i2c1 {
    status = "okay";

    mpu6050@68 {
        compatible = "my,mpu6050";
        reg = <0x68>;
        interrupt-parent = <&gpio1>;
        interrupts = <RK_PB3 4>;  // 根据实际硬件修改
    };
};
```

#### 7.3.2 更新设备树
```bash
# 编译设备树
make dtbs

# 将编译好的dtb文件复制到boot分区
sudo cp arch/arm/boot/dts/your-device.dtb /boot/

# 重启系统
sudo reboot
```

#### 7.3.3 加载驱动
```bash
# 加载内核模块
sudo insmod driver/mpu6050_drv.ko

# 检查设备节点
ls -l /dev/mpu6050

# 查看内核日志
dmesg | grep mpu6050
```

#### 7.3.4 验证I2C通信
```bash
# 检测I2C设备
i2cdetect -y 1

# 应该能看到 0x68 地址
```

---

## 8. 使用示例

### 8.1 运行应用程序

```bash
cd /home/gm/Workspace/LinuxDriver/mpu6050_drv2/app
sudo ./mpu6050_app
```

### 8.2 输出示例

```
Keep sensor still! Calibrating gyro...
Calibration Done! Bias X:0.023 Y:-0.012 Z:0.008
Starting Kalman Filter Fusion...
Roll:    0.1 | Pitch:   0.2 | Yaw:   0.0 | Temp: 25.3
```

### 8.3 测试姿态变化

| 操作 | Roll变化 | Pitch变化 | Yaw变化 |
|------|---------|----------|---------|
| 向左倾斜 | 负值增大 | - | - |
| 向右倾斜 | 正值增大 | - | - |
| 向前倾斜 | - | 负值增大 | - |
| 向后倾斜 | - | 正值增大 | - |
| 水平旋转 | - | - | 持续变化 |

### 8.4 调试技巧

#### 8.4.1 查看原始数据
修改应用程序，打印原始值：
```c
printf("AX:%6d AY:%6d AZ:%6d | GX:%6d GY:%6d GZ:%6d\n",
       ax_raw, ay_raw, az_raw, gx_raw, gy_raw, gz_raw);
```

#### 8.4.2 调整卡尔曼参数
```c
k->Q_angle = 0.001f;  // 调小更相信预测
k->Q_bias = 0.003f;
k->R_measure = 0.03f; // 调大更相信加速度计
```

#### 8.4.3 查看中断统计
```bash
cat /proc/interrupts | grep mpu6050
```

---

## 9. 故障排查

### 9.1 驱动加载失败

#### 问题：insmod 失败，提示 "Invalid module format"
**原因**：内核版本不匹配
**解决**：
```bash
# 检查当前内核版本
uname -r

# 使用正确的内核头文件重新编译
make clean
make
```

#### 问题：probe 函数未被调用
**原因**：设备树compatible属性不匹配
**解决**：
```bash
# 检查设备树
dmesg | grep mpu6050

# 确认compatible字符串一致
# 驱动中: "my,mpu6050"
# 设备树中: compatible = "my,mpu6050";
```

### 9.2 I2C通信问题

#### 问题：i2cdetect 检测不到设备
**原因**：
1. 硬件连接错误
2. I2C地址错误
3. 电源未供电

**解决**：
```bash
# 检查I2C总线
i2cdetect -y 1

# 检查电源
cat /sys/class/regulator/regulator.*/name

# 测试I2C通信
i2cget -y 1 0x68 0x75
# 应返回 0x68 (WHO_AM_I寄存器)
```

### 9.3 中断问题

#### 问题：中断风暴，系统卡死
**原因**：中断配置错误或未清除中断标志
**解决**：
```bash
# 查看中断统计
cat /proc/interrupts

# 检查设备树中断配置
# 确保触发方式与驱动一致
# 驱动: IRQF_TRIGGER_FALLING
# 设备树: interrupts = <pin 2>; (2=Falling edge)
```

#### 问题：read() 阻塞不返回
**原因**：
1. 中断未触发
2. 中断处理函数未执行
3. 等待队列未唤醒

**解决**：
```bash
# 检查中断是否触发
cat /proc/interrupts

# 查看内核日志
dmesg | tail -20

# 手动触发中断测试
echo 1 > /sys/class/gpio/gpioXX/value
```

### 9.4 数据异常

#### 问题：读取的数据全为0
**原因**：
1. MPU6050未唤醒
2. 寄存器配置错误

**解决**：
```bash
# 使用i2c工具直接读取
i2cget -y 1 0x68 0x3B w  # 读取加速度X高字节
i2cget -y 1 0x68 0x3C w  # 读取加速度X低字节

# 检查电源管理寄存器
i2cget -y 1 0x68 0x6B    # 应为 0x00 (唤醒状态)
```

#### 问题：角度漂移严重
**原因**：
1. 零点校准不准确
2. 卡尔曼参数不合适
3. 传感器温度漂移

**解决**：
```c
// 1. 重新校准零点
// 确保传感器静止，采集更多数据
const int CALIB_COUNT = 1000;  // 增加到1000次

// 2. 调整卡尔曼参数
k->Q_bias = 0.001f;  // 减小，更相信零点稳定

// 3. 添加温度补偿
// 根据温度调整零点偏移
```

### 9.5 性能问题

#### 问题：CPU占用率高
**原因**：采样率过高
**解决**：
```c
// 降低采样率
i2c_smbus_write_byte_data(client, REG_SMPLRT_DIV, 9);
// 1kHz / (1+9) = 100Hz

// 或增加低通滤波
i2c_smbus_write_byte_data(client, REG_CONFIG, 0x03);
// 带宽 44Hz
```

### 9.6 常用调试命令

```bash
# 查看内核日志
dmesg | grep mpu6050

# 查看设备节点
ls -l /dev/mpu6050

# 查看中断统计
cat /proc/interrupts

# 查看I2C设备
i2cdetect -y 1

# 读取寄存器
i2cget -y 1 0x68 0x75

# 写入寄存器
i2cset -y 1 0x68 0x6B 0x00

# 卸载驱动
sudo rmmod mpu6050_drv

# 重新加载驱动
sudo insmod driver/mpu6050_drv.ko
```

---

## 附录

### A. MPU6050寄存器速查表

| 地址 | 名称 | 默认值 | 说明 |
|------|------|--------|------|
| 0x19 | SMPLRT_DIV | 0x00 | 采样率分频器 |
| 0x1A | CONFIG | 0x00 | DLPF配置 |
| 0x1B | GYRO_CONFIG | 0x00 | 陀螺仪量程 |
| 0x1C | ACCEL_CONFIG | 0x00 | 加速度计量程 |
| 0x37 | INT_PIN_CFG | 0x00 | 中断引脚配置 |
| 0x38 | INT_ENABLE | 0x00 | 中断使能 |
| 0x3A | INT_STATUS | 0x00 | 中断状态 |
| 0x3B | ACCEL_XOUT_H | - | 加速度X高字节 |
| 0x3C | ACCEL_XOUT_L | - | 加速度X低字节 |
| 0x3D | ACCEL_YOUT_H | - | 加速度Y高字节 |
| 0x3E | ACCEL_YOUT_L | - | 加速度Y低字节 |
| 0x3F | ACCEL_ZOUT_H | - | 加速度Z高字节 |
| 0x40 | ACCEL_ZOUT_L | - | 加速度Z低字节 |
| 0x41 | TEMP_OUT_H | - | 温度高字节 |
| 0x42 | TEMP_OUT_L | - | 温度低字节 |
| 0x43 | GYRO_XOUT_H | - | 陀螺仪X高字节 |
| 0x44 | GYRO_XOUT_L | - | 陀螺仪X低字节 |
| 0x45 | GYRO_YOUT_H | - | 陀螺仪Y高字节 |
| 0x46 | GYRO_YOUT_L | - | 陀螺仪Y低字节 |
| 0x47 | GYRO_ZOUT_H | - | 陀螺仪Z高字节 |
| 0x48 | GYRO_ZOUT_L | - | 陀螺仪Z低字节 |
| 0x6B | PWR_MGMT_1 | 0x40 | 电源管理1 |
| 0x6C | PWR_MGMT_2 | 0x00 | 电源管理2 |
| 0x75 | WHO_AM_I | 0x68 | 设备ID |

### B. 量程配置

#### 加速度计量程 (ACCEL_CONFIG)

| AFS_SEL | 量程 | 灵敏度 (LSB/g) |
|---------|------|---------------|
| 0 | ±2g | 16384 |
| 1 | ±4g | 8192 |
| 2 | ±8g | 4096 |
| 3 | ±16g | 2048 |

#### 陀螺仪量程 (GYRO_CONFIG)

| FS_SEL | 量程 (°/s) | 灵敏度 (LSB/°/s) |
|--------|-----------|-----------------|
| 0 | ±250 | 131 |
| 1 | ±500 | 65.5 |
| 2 | ±1000 | 32.8 |
| 3 | ±2000 | 16.4 |

### C. DLPF带宽配置 (CONFIG)

| DLPF_CFG | 加速度计带宽 | 陀螺仪带宽 | 采样率 |
|----------|-------------|-----------|--------|
| 0 | 260Hz | 256Hz | 8kHz |
| 1 | 184Hz | 188Hz | 1kHz |
| 2 | 94Hz | 98Hz | 1kHz |
| 3 | 44Hz | 42Hz | 1kHz |
| 4 | 21Hz | 20Hz | 1kHz |
| 5 | 10Hz | 10Hz | 1kHz |
| 6 | 5Hz | 5Hz | 1kHz |

### D. 参考资料

1. [MPU6050数据手册](https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf)
2. [Linux I2C驱动开发指南](https://www.kernel.org/doc/html/latest/driver-api/i2c.html)
3. [Linux中断处理](https://www.kernel.org/doc/html/latest/core-api/irq/interrupts.html)
4. [卡尔曼滤波原理](https://en.wikipedia.org/wiki/Kalman_filter)

---

**文档版本**：v1.0
**最后更新**：2026-02-07
**维护者**：Linux Driver Team
